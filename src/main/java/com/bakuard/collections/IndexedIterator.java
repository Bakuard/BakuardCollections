package com.bakuard.collections;

import java.util.Iterator;

/**
 * Последовательно перебирает элементы любой линейной структуры данных. Элементы можно перебирать в обоих
 * направлениях.<br/>
 * Как и стандартный Iterator, поддерживает политику fail fast - выбрасывает ConcurrentModificationException,
 * если выполняются два следующих условия:<br/>
 * 1. Итерируемая структура данных была изменена после создания итератора.<br/>
 * 2. Был вызван один из методов итератора, отвечающих за получение следующего или предыдущего элемента.
 */
public interface IndexedIterator<T> extends Iterator<T> {

    /**
     * Возвращает true, если в перебираемой структуре данных есть элемент с индексом равным
     * {@link #recentIndex()} + 1. Иначе, возвращает false.
     */
    @Override
    public boolean hasNext();

    /**
     * Возвращает следующий элемент, индекс которого в итерируемой структуре данных равен
     * {@link #recentIndex()} + 1. Если такого элемента нет - выбрасывает исключение.
     * @throws java.util.NoSuchElementException если в итерируемой структуре данных нет элемента
     *                                          с большим индексом, чем индекс последнего полученного
     *                                          через итератор элемента.
     */
    @Override
    public T next();

    /**
     * Возвращает true, если в перебираемой структуре данных есть элемент с индексом равным
     * {@link #recentIndex()} - 1. Иначе, возвращает false.
     */
    public boolean hasPrevious();

    /**
     * Возвращает предыдущий элемент, индекс которого в итерируемой структуре данных равен
     * {@link #recentIndex()} - 1. Если такого элемента нет - выбрасывает исключение.
     * @throws java.util.NoSuchElementException если в итерируемой структуре данных нет элемента
     *                                          с меньшим индексом, чем индекс последнего полученного
     *                                          через итератор элемента.
     */
    public T previous();

    /**
     * Возвращает true, если в перебираемой структуре данных есть элемент с индексом равным
     * {@link #recentIndex()} + itemsNumber. Иначе, возвращает false. Параметр itemsNumber
     * может быть отрицательным числом. <br/><br/>
     * Например: вызов метода {@link #hasNext()} эквивалентен вызову этого метода с параметром 1.
     * А вызов метода {@link #hasPrevious()} эквивалентен вызову этого метода с параметром -1.
     * @param itemsNumber кол-во элементов относительно последнего элемента возвращенного итератором.
     */
    public boolean canJump(int itemsNumber);

    /**
     * Возвращает элемент, индекс которого в итерируемой структуре данных равен
     * {@link #recentIndex()} + itemsNumber. Если такого элемента нет - выбрасывает исключение.
     * Параметр itemsNumber может быть отрицательным числом.
     * @throws java.util.NoSuchElementException если в итерируемой структуре данных нет элемента
     *                                          с индексом равным {@link #recentIndex()} + itemsNumber.
     */
    public T jump(int itemsNumber);

    /**
     * Устанавливает курсор итератора перед первым элементом, т.е. вызов {@link #next()}
     * после вызова данного метода вернет первый элемент.
     */
    public void beforeFirst();

    /**
     * Устанавливает курсор итератора после последнего элемента, т.е. вызов {@link #previous()}
     * после вызова данного метода вернет последний элемент.
     */
    public void afterLast();

    /**
     * Возвращает индекс последнего элемента полученного через данный итератор. Метод также может вернуть
     * -1, если выполняется любое из двух условий: <br/>
     * 1. если итерируемая структура данных пуста. <br/>
     * 2. если ни разу не был вызван ни один из методов итератора, отвечающих за получение следующего
     * или предыдущего элемента.
     */
    public int recentIndex();

}
