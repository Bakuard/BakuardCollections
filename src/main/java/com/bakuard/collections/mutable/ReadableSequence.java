package com.bakuard.collections.mutable;

import java.util.Objects;
import java.util.function.Predicate;

/**
 * Общий интерфейс для всех структур данных сохраняющих порядок добавления элементов и поддерживающих
 * произвольный доступ к своим элементам за константное время.
 */
public interface ReadableSequence<T> extends Iterable<T> {

    /**
     * Возвращает элемент по его индексу. Первому элементу соответствует индекс [0], последнему
     * элементу соответствует индекс [{@link #size()} - 1]. <br/>
     * Метод также допускает отрицательные индексы. Элементу с индексом [-1] соответствует последний
     * элемент, а элементу с индексом [-({@link #size()})] - первый элемент.
     * @param index индекс искомого элемента.
     * @throws IndexOutOfBoundsException если index < [-({@link #size()})] или index >= [{@link #size()}]
     */
    public T get(int index);

    /**
     * Возвращает первый элемент упорядоченной структуры данных поддерживающей произвольный
     * доступ к своим элементам. Первому элементу соответствует элемент под индексом [0]. Если
     * структура данных пуста - возвращает null.
     */
    public T getFirst();

    /**
     * Возвращает последний элемент упорядоченной структуры данных поддерживающей произвольный
     * доступ к своим элементам. Последнему элементу соответствует элемент под индексом [{@link #size()} - 1].
     * Если структура данных пуста - возвращает null.
     */
    public T getLast();

    /**
     * Возвращает кол-во элементов.
     */
    public int size();

    /**
     * Возвращает true, если кол-во элементов равно нулю, иначе - false.
     */
    public default boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Возвращает индекс первого встретившегося элемента равного заданному
     * значению. Выполняет линейный поиск начиная с элемента {@link #getFirst()}
     * в направлении элемента {@link #getLast()}.
     * Если нет элемента равного заданному значению - возвращает -1.
     * @param value значение искомого элемента.
     * @return индекс первого встретившегося элемента соответствующего заданному предикату.
     */
    public default int linearSearch(T value) {
        return linearSearch(current -> Objects.equals(current, value));
    }

    /**
     * Возвращает индекс первого встретившегося элемента соответствующего заданному
     * предикату. Выполняет линейный поиск начиная с элемента {@link #getFirst()}
     * в направлении элемента {@link #getLast()}.
     * Если нет элемента соответствующего заданному предикату - возвращает -1.
     * @param predicate условие, которому должен соответствовать искомый элемент.
     * @return индекс первого встретившегося элемента соответствующего заданному предикату.
     */
    public int linearSearch(Predicate<T> predicate);

    /**
     * Возвращает индекс первого встретившегося элемента соответствующего заданному
     * предикату. Выполняет линейный поиск начиная с элемента {@link #getLast()}
     * в направлении элемента {@link #getFirst()}.
     * Если нет элемента соответствующего заданному предикату - возвращает -1.
     * @param predicate условие, которому должен соответствовать искомый элемент.
     * @return индекс первого встретившегося элемента соответствующего заданному предикату.
     */
    public int linearSearchLast(Predicate<T> predicate);

    /**
     * Проверяет - содержит ли структура данных элемент с заданным значением. Если это верно - возвращает
     * true, иначе - false.
     * @param value значение искомого элемента.
     */
    public default boolean contains(T value) {
        return linearSearch(value) != -1;
    }

    /**
     * Проверяет - содержит ли структура данных элемент удовлетворяющий заданному предикату.
     * Если это верно - возвращает true, иначе - false.
     * @param predicate условие, которому должен соответствовать искомый элемент.
     */
    public default boolean contains(Predicate<T> predicate) {
        return linearSearch(predicate) != -1;
    }

}
